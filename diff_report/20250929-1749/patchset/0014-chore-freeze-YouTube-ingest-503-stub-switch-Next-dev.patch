From 44f13b42e052beec1981042f31881db7adf9f5da Mon Sep 17 00:00:00 2001
From: zhenya3133 <verbenkoe@gmail.com>
Date: Sun, 28 Sep 2025 16:53:27 +0300
Subject: [PATCH 14/14] chore: freeze YouTube ingest (503 stub); switch Next
 dev off turbopack; seed+OCR pipeline; add whisper-only & desktop ingest
 scripts; next: folder monitor

---
 apps/web/package.json                         |  43 +-
 apps/web/scripts/ingest_youtube_via_seed.sh   | 213 ++++++++
 .../ingest_youtube_via_seed_whisper_only.sh   | 140 +++++
 apps/web/src/app/api/ingest/youtube/route.ts  | 513 +-----------------
 4 files changed, 421 insertions(+), 488 deletions(-)
 create mode 100755 apps/web/scripts/ingest_youtube_via_seed.sh
 create mode 100755 apps/web/scripts/ingest_youtube_via_seed_whisper_only.sh

diff --git a/apps/web/package.json b/apps/web/package.json
index e78944b..d32acba 100644
--- a/apps/web/package.json
+++ b/apps/web/package.json
@@ -1 +1,42 @@
-{"name":"web","version":"0.1.0","private":true,"scripts":{"dev":"next dev --turbopack","build":"next build","start":"next start","lint":"next lint","migrate:g0":"node ./scripts/migrate-g0.js","smoke":"pwsh ./apps/web/tests/Smoke-Evals.ps1"},"dependencies":{"@mozilla/readability":"^0.6.0","cheerio":"^1.1.2","dotenv":"^17.2.1","ffmpeg-static":"^5.2.0","fluent-ffmpeg":"^2.1.3","gray-matter":"^4.0.3","jsdom":"^26.1.0","next":"15.4.6","openai":"^5.23.1","pdf-parse":"^1.1.1","pg":"^8.16.3","react":"19.1.0","react-dom":"19.1.0","youtube-transcript":"^1.2.1","ytdl-core":"^4.11.5","zod":"^3.25.76"},"devDependencies":{"@eslint/eslintrc":"^3","@types/node":"^20","@types/pg":"^8.15.5","@types/react":"^19","@types/react-dom":"^19","eslint":"^9","eslint-config-next":"15.4.6","typescript":"^5"}}
\ No newline at end of file
+{
+  "name": "web",
+  "version": "0.1.0",
+  "private": true,
+  "scripts": {
+    "dev": "next dev",
+    "dev:tp": "next dev --turbopack",
+    "build": "next build",
+    "start": "next start",
+    "lint": "next lint",
+    "migrate:g0": "node ./scripts/migrate-g0.js",
+    "smoke": "pwsh ./apps/web/tests/Smoke-Evals.ps1"
+  },
+  "dependencies": {
+    "@mozilla/readability": "^0.6.0",
+    "cheerio": "^1.1.2",
+    "dotenv": "^17.2.1",
+    "ffmpeg-static": "^5.2.0",
+    "fluent-ffmpeg": "^2.1.3",
+    "gray-matter": "^4.0.3",
+    "jsdom": "^26.1.0",
+    "next": "15.4.6",
+    "openai": "^5.23.1",
+    "pdf-parse": "^1.1.1",
+    "pg": "^8.16.3",
+    "react": "19.1.0",
+    "react-dom": "19.1.0",
+    "youtube-transcript": "^1.2.1",
+    "ytdl-core": "^4.11.5",
+    "zod": "^3.25.76"
+  },
+  "devDependencies": {
+    "@eslint/eslintrc": "^3",
+    "@types/node": "^20",
+    "@types/pg": "^8.15.5",
+    "@types/react": "^19",
+    "@types/react-dom": "^19",
+    "eslint": "^9",
+    "eslint-config-next": "15.4.6",
+    "typescript": "^5"
+  }
+}
diff --git a/apps/web/scripts/ingest_youtube_via_seed.sh b/apps/web/scripts/ingest_youtube_via_seed.sh
new file mode 100755
index 0000000..ac6fa40
--- /dev/null
+++ b/apps/web/scripts/ingest_youtube_via_seed.sh
@@ -0,0 +1,213 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+# ==== Требуемые переменные окружения ====
+: "${BASE:?need BASE, e.g. http://localhost:3000}"
+: "${X_ADMIN_KEY:?need X_ADMIN_KEY (из .env.local)}"
+: "${NS:?need NS, e.g. rebecca/army/refs}"
+: "${SLOT:=staging}"
+
+# Whisper fallback (только если нет субтитров):
+OPENAI_API_KEY="${OPENAI_API_KEY:-}"
+WHISPER_MODEL="${WHISPER_MODEL:-whisper-1}"
+
+URL="${1:-}"
+if [[ -z "$URL" ]]; then
+  echo "Usage: $0 <youtube_url_or_id>  [max_seconds]" >&2
+  exit 1
+fi
+MAX_SEC="${2:-900}"   # по умолчанию 15 минут
+
+# ==== Вспомогательные ====
+tmpdir="$(mktemp -d -t ytseed-XXXXXX)"
+cleanup() { rm -rf "$tmpdir" || true; }
+trap cleanup EXIT
+
+# Простая функция логов
+log(){ printf '[yt-seed] %s\n' "$*"; }
+
+# Извлечём ID (11 символов) из URL/ID
+ensure_id() {
+  local in="$1"
+  if [[ "$in" =~ ^[A-Za-z0-9_-]{11}$ ]]; then
+    echo "$in"; return 0
+  fi
+  # пробуем достать из v=...
+  if [[ "$in" =~ v=([A-Za-z0-9_-]{11}) ]]; then
+    echo "${BASH_REMATCH[1]}"; return 0
+  fi
+  # короткая форма youtu.be/ID
+  if [[ "$in" =~ youtu\.be/([A-Za-z0-9_-]{11}) ]]; then
+    echo "${BASH_REMATCH[1]}"; return 0
+  fi
+  return 1
+}
+
+VID="$(ensure_id "$URL" || true)"
+if [[ -z "$VID" ]]; then
+  echo "Cannot parse video id from: $URL" >&2
+  exit 1
+fi
+
+log "Video ID: $VID"
+work="$tmpdir/${VID}"
+mkdir -p "$work"
+
+# ==== 1) Пытаемся выкачать автосабы через yt-dlp ====
+log "Trying to fetch auto-subs (ru,en)..."
+set +e
+yt-dlp \
+  --skip-download \
+  --write-auto-subs \
+  --sub-lang "ru,en" \
+  --sub-format "vtt" \
+  -o "$work/%(id)s.%(ext)s" \
+  "https://www.youtube.com/watch?v=${VID}" \
+  >/dev/null 2>&1
+rc=$?
+set -e
+
+txt="$work/${VID}.txt"
+have_subs="0"
+
+for vtt in "$work/${VID}."*.vtt; do
+  if [[ -f "$vtt" ]]; then
+    log "Found subs: $(basename "$vtt") -> convert to txt"
+    python3 - "$vtt" "$txt" <<'PY'
+import sys, re
+vtt, out = sys.argv[1], sys.argv[2]
+def strip_vtt(text: str) -> str:
+    # убираем заголовки, таймкоды, веб-вебвтт метаданные
+    lines = []
+    for line in text.splitlines():
+        if line.startswith("WEBVTT"): continue
+        if re.match(r'^\d{2}:\d{2}:\d{2}\.\d{3}\s--> ', line): continue
+        if re.match(r'^\d+\s*$', line): continue
+        line = re.sub(r'<[^>]+>', '', line)  # html-теги
+        line = line.strip()
+        if line:
+            lines.append(line)
+    # иногда субтитры покадрово — склеиваем и убираем повторы
+    text = ' '.join(lines)
+    text = re.sub(r'\s+', ' ', text)
+    return text.strip()
+
+with open(vtt, 'r', encoding='utf-8', errors='ignore') as f:
+    raw = f.read()
+clean = strip_vtt(raw)
+with open(out, 'w', encoding='utf-8') as f:
+    f.write(clean + "\n")
+PY
+    if [[ -s "$txt" ]]; then
+      have_subs="1"
+      break
+    fi
+  fi
+done
+
+# ==== 2) Если субтитров нет — Whisper fallback ====
+if [[ "$have_subs" != "1" ]]; then
+  if [[ -z "$OPENAI_API_KEY" ]]; then
+    echo "No subs and OPENAI_API_KEY is empty. Cannot transcribe via Whisper." >&2
+    exit 1
+  fi
+  log "No subs. Extract audio and transcribe with Whisper..."
+
+  wav="$work/${VID}.wav"
+  # bestaudio -> wav 16k mono, обрезаем до MAX_SEC
+  ffmpeg -hide_banner -loglevel error \
+    -ss 0 -t "$MAX_SEC" \
+    -i "$(yt-dlp -f bestaudio --no-check-certificates -g "https://www.youtube.com/watch?v=${VID}")" \
+    -ac 1 -ar 16000 -vn -f wav "$wav"
+
+  log "Send to Whisper API..."
+  # multipart/form-data через curl
+  resp="$work/whisper.json"
+  curl -sS -X POST "https://api.openai.com/v1/audio/transcriptions" \
+    -H "Authorization: Bearer ${OPENAI_API_KEY}" \
+    -H "Content-Type: multipart/form-data" \
+    -F "model=${WHISPER_MODEL}" \
+    -F "response_format=text" \
+    -F "file=@${wav}" \
+    > "$txt"
+
+  if [[ ! -s "$txt" ]]; then
+    echo "Whisper transcription failed (empty output)" >&2
+    exit 1
+  fi
+fi
+
+# ==== 3) Чанкуем и готовим payload под /api/ingest/seed ====
+log "Chunking text..."
+chunks="$work/chunks.json"
+python3 - "$txt" "$chunks" <<'PY'
+import sys, json, re
+inp, outp = sys.argv[1], sys.argv[2]
+CHARS = 1200
+OVER  = 120
+with open(inp, 'r', encoding='utf-8', errors='ignore') as f:
+    txt = f.read()
+txt = re.sub(r'\s+', ' ', txt).strip()
+parts = []
+i = 0; k = 0
+n = len(txt)
+while i < n:
+    part = txt[i:i+CHARS].strip()
+    if part:
+        parts.append({"chunk_no": k, "content": part})
+        k += 1
+    if i + CHARS >= n: break
+    i += CHARS - OVER
+with open(outp, 'w', encoding='utf-8') as f:
+    json.dump(parts, f, ensure_ascii=False)
+PY
+
+if [[ ! -s "$chunks" ]]; then
+  echo "No chunks produced" >&2
+  exit 1
+fi
+
+# ==== 4) Собираем seed payload и шлём ====
+log "POST /api/ingest/seed ..."
+payload="$work/seed_payload.json"
+jq -n \
+  --arg ns "$NS" \
+  --arg slot "$SLOT" \
+  --arg sid "youtube:${VID}" \
+  --arg url "https://www.youtube.com/watch?v=${VID}" \
+  --arg title "$VID" \
+  --slurpfile ch "$chunks" \
+'{
+  ns: $ns,
+  slot: $slot,
+  items: [{
+    source_id: $sid,
+    url: $url,
+    title: $title,
+    source_type: "youtube",
+    kind: "youtube-seed",
+    doc_metadata: { ingest: "seed", note: "yt via seed" },
+    chunks: $ch[0]
+  }],
+  minChars: 32,
+  dryRun: false
+}' > "$payload"
+
+curl -sS -X POST "$BASE/api/ingest/seed" \
+  -H "content-type: application/json" \
+  -H "x-admin-key: $X_ADMIN_KEY" \
+  --data-binary @"$payload" | jq '{ok, textChunks, textInserted, textUpdated, unchanged, targetsCount, ms, error}'
+
+# ==== 5) Запишем эмбеддинги ====
+if [[ -d "$(dirname "$0")/.." ]]; then
+  pushd "$(dirname "$0")/.." >/dev/null
+  if [[ -x "./scripts/embed_backfill.sh" ]]; then
+    log "Running embed_backfill..."
+    ADMIN_KEY="${ADMIN_KEY:-$X_ADMIN_KEY}" ./scripts/embed_backfill.sh "$NS" "$SLOT" | jq .
+  else
+    log "Warning: scripts/embed_backfill.sh not found or not executable"
+  fi
+  popd >/dev/null
+fi
+
+log "Done."
diff --git a/apps/web/scripts/ingest_youtube_via_seed_whisper_only.sh b/apps/web/scripts/ingest_youtube_via_seed_whisper_only.sh
new file mode 100755
index 0000000..e2f7ac7
--- /dev/null
+++ b/apps/web/scripts/ingest_youtube_via_seed_whisper_only.sh
@@ -0,0 +1,140 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+# ===== required env =====
+: "${BASE:?need BASE, e.g. http://localhost:3000}"
+: "${X_ADMIN_KEY:?need X_ADMIN_KEY (from .env.local)}"
+: "${NS:?need NS, e.g. rebecca/army/refs}"
+: "${SLOT:=staging}"
+: "${OPENAI_API_KEY:?need OPENAI_API_KEY (from .env.local)}"
+
+WHISPER_MODEL="${WHISPER_MODEL:-whisper-1}"
+
+URL="${1:-}"
+MAX_SEC="${2:-900}"   # default 15 min
+if [[ -z "$URL" ]]; then
+  echo "Usage: $0 <youtube_url_or_id> [max_seconds]" >&2
+  exit 1
+fi
+
+log(){ printf '[yt-whisper] %s\n' "$*"; }
+
+# extract 11-char video id
+ensure_id() {
+  local in="$1"
+  if [[ "$in" =~ ^[A-Za-z0-9_-]{11}$ ]]; then echo "$in"; return 0; fi
+  if [[ "$in" =~ v=([A-Za-z0-9_-]{11}) ]]; then echo "${BASH_REMATCH[1]}"; return 0; fi
+  if [[ "$in" =~ youtu\.be/([A-Za-z0-9_-]{11}) ]]; then echo "${BASH_REMATCH[1]}"; return 0; fi
+  return 1
+}
+
+VID="$(ensure_id "$URL" || true)"
+if [[ -z "$VID" ]]; then
+  echo "Cannot parse video id from: $URL" >&2
+  exit 1
+fi
+
+tmpdir="$(mktemp -d -t ytwhisper-XXXXXX)"
+trap 'rm -rf "$tmpdir"' EXIT
+work="$tmpdir/$VID"; mkdir -p "$work"
+
+log "Video ID: $VID"
+
+# bestaudio direct URL (yt-dlp), convert to wav 16k mono, trim to MAX_SEC
+log "Extracting audio via yt-dlp + ffmpeg (<= ${MAX_SEC}s)…"
+WAV="$work/${VID}.wav"
+ffmpeg -hide_banner -loglevel error \
+  -ss 0 -t "$MAX_SEC" \
+  -i "$(yt-dlp -f bestaudio --no-check-certificates -g "https://www.youtube.com/watch?v=${VID}")" \
+  -ac 1 -ar 16000 -vn -f wav "$WAV"
+
+# Whisper API
+log "Transcribing via Whisper API…"
+TXT="$work/${VID}.txt"
+curl -sS -X POST "https://api.openai.com/v1/audio/transcriptions" \
+  -H "Authorization: Bearer ${OPENAI_API_KEY}" \
+  -H "Content-Type: multipart/form-data" \
+  -F "model=${WHISPER_MODEL}" \
+  -F "response_format=text" \
+  -F "file=@${WAV}" \
+  > "$TXT"
+
+if [[ ! -s "$TXT" ]]; then
+  echo "Whisper transcription failed (empty output)" >&2
+  exit 1
+fi
+
+# Chunk text
+log "Chunking text…"
+CHUNKS="$work/chunks.json"
+python3 - "$TXT" "$CHUNKS" <<'PY'
+import sys, json, re
+inp, outp = sys.argv[1], sys.argv[2]
+CHARS = 1200
+OVER  = 120
+with open(inp, 'r', encoding='utf-8', errors='ignore') as f:
+    txt = f.read()
+txt = re.sub(r'\s+', ' ', txt).strip()
+parts = []
+i = 0; k = 0; n = len(txt)
+while i < n:
+    part = txt[i:i+CHARS].strip()
+    if part:
+        parts.append({"chunk_no": k, "content": part})
+        k += 1
+    if i + CHARS >= n: break
+    i += CHARS - OVER
+with open(outp, 'w', encoding='utf-8') as f:
+    json.dump(parts, f, ensure_ascii=False)
+PY
+
+if [[ ! -s "$CHUNKS" ]]; then
+  echo "No chunks produced" >&2
+  exit 1
+fi
+
+# Seed payload
+log "POST /api/ingest/seed …"
+PAYLOAD="$work/seed_payload.json"
+jq -n \
+  --arg ns "$NS" \
+  --arg slot "$SLOT" \
+  --arg sid "youtube:${VID}" \
+  --arg url "https://www.youtube.com/watch?v=${VID}" \
+  --arg title "$VID" \
+  --slurpfile ch "$CHUNKS" \
+'{
+  ns: $ns,
+  slot: $slot,
+  items: [{
+    source_id: $sid,
+    url: $url,
+    title: $title,
+    source_type: "youtube",
+    kind: "youtube-whisper",
+    doc_metadata: { ingest: "seed", note: "yt whisper only" },
+    chunks: $ch[0]
+  }],
+  minChars: 32,
+  dryRun: false
+}' > "$PAYLOAD"
+
+curl -sS -X POST "$BASE/api/ingest/seed" \
+  -H "content-type: application/json" \
+  -H "x-admin-key: $X_ADMIN_KEY" \
+  --data-binary @"$PAYLOAD" \
+  | jq '{ok, textChunks, textInserted, textUpdated, unchanged, targetsCount, ms, error}'
+
+# Backfill
+if [[ -d "$(dirname "$0")/.." ]]; then
+  pushd "$(dirname "$0")/.." >/dev/null
+  if [[ -x "./scripts/embed_backfill.sh" ]]; then
+    log "Running embed_backfill…"
+    ADMIN_KEY="${ADMIN_KEY:-$X_ADMIN_KEY}" ./scripts/embed_backfill.sh "$NS" "$SLOT" | jq .
+  else
+    log "Warning: scripts/embed_backfill.sh not found or not executable"
+  fi
+  popd >/dev/null
+fi
+
+log "Done."
diff --git a/apps/web/src/app/api/ingest/youtube/route.ts b/apps/web/src/app/api/ingest/youtube/route.ts
index 0a12501..46a0558 100755
--- a/apps/web/src/app/api/ingest/youtube/route.ts
+++ b/apps/web/src/app/api/ingest/youtube/route.ts
@@ -1,500 +1,39 @@
 // apps/web/src/app/api/ingest/youtube/route.ts
 import { NextResponse } from "next/server";
-import { embedMany } from "@/lib/embeddings";
-import { chunkText, normalizeChunkOpts } from "@/lib/chunking";
-import { retryFetch } from "@/lib/retryFetch";
-import { assertAdmin } from "@/lib/admin";
-import { upsertChunksWithTargets, type IngestDoc } from "@/lib/ingest_upsert";
 
-import fs from "node:fs";
-import os from "node:os";
-import path from "node:path";
-import ytdl from "ytdl-core";
-import ffmpeg from "fluent-ffmpeg";
-import ffmpegStaticPath from "ffmpeg-static";
-import { OpenAI } from "openai";
+/**
+ * ЖЁСТКАЯ ЗАГЛУШКА YouTube-инжеста.
+ * Всегда возвращает 503 и не выполняет никакой логики.
+ * Оставлена переменная флага на будущее (YT_INGEST_DISABLED),
+ * но по факту тут всё равно 503.
+ */
 
 export const runtime = "nodejs";
 export const dynamic = "force-dynamic";
 
-type Body = {
-  ns: string;
-  slot?: "staging" | "prod" | string | null;
-  kind?: string | null;
-
-  url?: string | null;
-  videoId?: string | null;
-  lang?: string | null;
-  includeTimestamps?: boolean | null;
-
-  dryRun?: boolean | null;
-  skipEmbeddings?: boolean | null;
-  chunk?: { chars?: number; overlap?: number };
-  minChars?: number | null;
-};
-
-const UA =
-  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36";
-
-// ---------- ffmpeg path resolve (force system first) ----------
-const SYSTEM_FFMPEG = (process.env.FFMPEG_PATH || "/usr/bin/ffmpeg").trim();
-const STATIC_FFMPEG = String(ffmpegStaticPath || "").trim();
-
-const pickFfmpeg = () => {
-  try {
-    if (SYSTEM_FFMPEG && fs.existsSync(SYSTEM_FFMPEG)) return SYSTEM_FFMPEG;
-  } catch {}
-  try {
-    if (STATIC_FFMPEG && fs.existsSync(STATIC_FFMPEG)) return STATIC_FFMPEG;
-  } catch {}
-  return "ffmpeg"; // fallback to PATH
-};
-
-const RESOLVED_FFMPEG = pickFfmpeg();
-ffmpeg.setFfmpegPath(RESOLVED_FFMPEG);
-
-// ----------------- utils -----------------
-
-function ensureVideoId(input?: string | null): string | null {
-  const s = (input || "").trim();
-  if (!s) return null;
-  if (/^[A-Za-z0-9_-]{11}$/.test(s)) return s;
-  try {
-    const u = new URL(s);
-    const v = u.searchParams.get("v");
-    if (v && /^[A-Za-z0-9_-]{11}$/.test(v)) return v;
-    if (u.hostname.includes("youtu.be")) {
-      const id = u.pathname.replace(/^\/+/, "");
-      if (/^[A-Za-z0-9_-]{11}$/.test(id)) return id;
-    }
-  } catch {}
-  return null;
-}
-
-async function oembed(url: string) {
-  try {
-    const res = await retryFetch(
-      `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`,
-      { headers: { "User-Agent": UA } }
-    );
-    if (!res.ok) return null;
-    const j = await res.json();
-    return {
-      title: (j?.title as string) || null,
-      author_name: (j?.author_name as string) || null,
-      thumbnail_url: (j?.thumbnail_url as string) || null,
-    };
-  } catch {
-    return null;
-  }
-}
-
-type TranscriptItem = { text: string; offset?: number; duration?: number };
-
-function decodeHTMLEntities(s: string): string {
-  const map: Record<string, string> = {
-    "&amp;": "&",
-    "&lt;": "<",
-    "&gt;": ">",
-    "&quot;": '"',
-    "&#39;": "'",
-  };
-  return s
-    .replace(/&(amp|lt|gt|quot|#39);/g, (m) => map[m] || m)
-    .replace(/&#(\d+);/g, (_, d) => {
-      const code = Number(d);
-      return Number.isFinite(code) ? String.fromCharCode(code) : _;
-    });
-}
-
-// --- путь 1: публичный сервис youtubetranscript.rip ---
-async function fetchViaRip(videoId: string, lang?: string | null): Promise<TranscriptItem[]> {
-  const tryOnce = async (url: string) => {
-    const res = await retryFetch(url, { headers: { "User-Agent": UA } });
-    if (!res.ok) return null;
-    const j = await res.json().catch(() => null);
-    if (!j) return null;
-    const arr: any[] = Array.isArray(j)
-      ? j
-      : Array.isArray((j as any).transcripts)
-      ? (j as any).transcripts
-      : [];
-    return arr.map((x: any) => ({
-      text: x?.text ?? "",
-      offset: Number(x?.offset ?? x?.start) || undefined,
-      duration: Number(x?.duration) || undefined,
-    })) as TranscriptItem[];
-  };
-  if (lang) {
-    const u = `https://youtubetranscript.rip/api/v1/?id=${encodeURIComponent(videoId)}&lang=${encodeURIComponent(lang)}`;
-    const withLang = await tryOnce(u);
-    if (withLang?.length) return withLang;
-  }
-  const u2 = `https://youtubetranscript.rip/api/v1/?id=${encodeURIComponent(videoId)}`;
-  const def = await tryOnce(u2);
-  return def ?? [];
-}
-
-// --- путь 2: прямой YouTube timedtext (XML), включая авто-сабы ---
-async function fetchViaTimedtext(videoId: string, lang?: string | null): Promise<TranscriptItem[]> {
-  const want = (lang || "").trim();
-  const candidates: string[] = [];
-  if (want) {
-    candidates.push(want);
-    if (want.includes("-")) candidates.push(want.split("-")[0]);
-  }
-  for (const x of ["en", "en-US", "en-GB", "ru", "ru-RU"]) {
-    if (!candidates.includes(x)) candidates.push(x);
-  }
-
-  const tryTimedText = async (l: string, asr: boolean) => {
-    const url =
-      `https://www.youtube.com/api/timedtext?v=${encodeURIComponent(videoId)}&lang=${encodeURIComponent(l)}` +
-      (asr ? "&kind=asr" : "");
-    const res = await retryFetch(url, {
-      headers: { "User-Agent": UA, Accept: "application/xml,text/xml,*/*" },
-    });
-    if (!res.ok) return null;
-    const xml = await res.text();
-    if (!xml || !xml.includes("<transcript")) return null;
-
-    const items: TranscriptItem[] = [];
-    const re = /<text\s+([^>]*?)>([\s\S]*?)<\/text>/gi;
-    let m: RegExpExecArray | null;
-    while ((m = re.exec(xml))) {
-      const attrs = m[1] || "";
-      const body = decodeHTMLEntities((m[2] || "").replace(/<[^>]+>/g, "").trim());
-      const startMatch = /(?:^|\s)start="([\d.]+)"/.exec(attrs);
-      const durMatch = /(?:^|\s)dur="([\d.]+)"/.exec(attrs);
-      const start = startMatch ? Number(startMatch[1]) : undefined;
-      const dur = durMatch ? Number(durMatch[1]) : undefined; // <-- fixed
-      const duration = Number.isFinite(dur) ? dur : undefined;
-      if (body) items.push({ text: body, offset: start, duration });
-    }
-    return items;
-  };
-
-  for (const l of candidates) {
-    const got = await tryTimedText(l, false);
-    if (got?.length) return got;
-  }
-  for (const l of candidates) {
-    const got = await tryTimedText(l, true);
-    if (got?.length) return got;
-  }
-  return [];
-}
-
-// --- путь 0: библиотека youtube-transcript (если доступна) ---
-async function fetchTranscript(videoId: string, lang?: string | null): Promise<TranscriptItem[]> {
-  try {
-    const { YoutubeTranscript } = await import("youtube-transcript" as any);
-    if (lang) {
-      const t = await (YoutubeTranscript as any).fetchTranscript(videoId, { lang });
-      if (t?.length) {
-        return t.map((x: any) => ({
-          text: x?.text || "",
-          offset: Number(x?.offset) || undefined,
-          duration: Number(x?.duration) || undefined,
-        }));
-      }
-    }
-    const t = await (YoutubeTranscript as any).fetchTranscript(videoId);
-    if (t?.length) {
-      return t.map((x: any) => ({
-        text: x?.text || "",
-        offset: Number(x?.offset) || undefined,
-        duration: Number(x?.duration) || undefined,
-      }));
-    }
-  } catch {}
-
-  try {
-    const rip = await fetchViaRip(videoId, lang);
-    if (rip?.length) return rip;
-  } catch {}
-
-  try {
-    const tt = await fetchViaTimedtext(videoId, lang);
-    if (tt?.length) return tt;
-  } catch {}
-
-  return [];
-}
-
-function msToTimestamp(ms?: number) {
-  if (!ms || ms < 0) return "00:00";
-  const total = Math.floor(ms / 1000);
-  const s = total % 60;
-  const m = Math.floor(total / 60) % 60;
-  const h = Math.floor(total / 3600);
-  const pad = (n: number) => (n < 10 ? `0${n}` : `${n}`);
-  return h > 0 ? `${h}:${pad(m)}:${pad(s)}` : `${pad(m)}:${pad(s)}`;
+// Унифицированный ответ
+function disabledResponse() {
+  return NextResponse.json(
+    {
+      ok: false,
+      error: "youtube ingest temporarily disabled",
+      hint:
+        "Фича отключена на время. Используй /api/ingest/seed или скрипты DOC/PDF/OCR.",
+      ts: new Date().toISOString(),
+    },
+    { status: 503 }
+  );
 }
 
-// ------------- Whisper fallback -------------
-
-async function downloadAudioToWav(videoIdOrUrl: string): Promise<string> {
-  const id = ensureVideoId(videoIdOrUrl);
-  if (!id) throw new Error("invalid YouTube url or id");
-
-  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "ytw-"));
-  const outPath = path.join(tmpDir, `${id}.wav`);
-
-  await new Promise<void>((resolve, reject) => {
-    const stream = ytdl(id, {
-      quality: "highestaudio",
-      filter: "audioonly",
-      highWaterMark: 1 << 25,
-    });
-
-    ffmpeg(stream as any)
-      // путь уже установлен глобально; повторно зададим явно на всякий случай
-      .setFfmpegPath(RESOLVED_FFMPEG)
-      .audioChannels(1)
-      .audioFrequency(16000)
-      .format("wav")
-      .on("error", reject)
-      .on("end", () => resolve())
-      .save(outPath);
-  });
-
-  return outPath;
+// Любой POST → 503
+export async function POST() {
+  return disabledResponse();
 }
 
-async function transcribeWithWhisper(filePath: string, language?: string | null): Promise<string> {
-  const apiKey = process.env.OPENAI_API_KEY;
-  if (!apiKey) throw new Error("OPENAI_API_KEY not set");
-  const openai = new OpenAI({ apiKey });
-
-  const file = fs.createReadStream(filePath);
-  const res = await (openai as any).audio.transcriptions.create({
-    model: "whisper-1",
-    file,
-    language: language || undefined,
-    response_format: "text",
-  });
-  const text = typeof res === "string" ? res : (res as any).text ?? "";
-  return String(text).replace(/\s+/g, " ").trim();
+// На случай, если кто-то пингует GET/HEAD — тоже 503
+export async function GET() {
+  return disabledResponse();
 }
-
-// ----------------- route -----------------
-
-export async function POST(req: Request) {
-  const t0 = Date.now();
-  let stage = "init";
-  let tmpAudio: string | null = null;
-
-  try {
-    assertAdmin(req);
-
-    const {
-      ns,
-      slot = "staging",
-      kind = "youtube",
-      url,
-      videoId: explicitId,
-      lang = null,
-      includeTimestamps = false,
-      dryRun = false,
-      skipEmbeddings = false,
-      chunk,
-      minChars: minCharsRaw = 64,
-    } = (await req.json()) as Body;
-
-    const minChars = Number.isFinite(Number(minCharsRaw)) ? Math.max(0, Number(minCharsRaw)) : 64;
-
-    if (!ns) {
-      return NextResponse.json({ ok: false, stage, error: "ns required" }, { status: 400 });
-    }
-    const vid = ensureVideoId(explicitId || url);
-    if (!vid) {
-      return NextResponse.json({ ok: false, stage, error: "video url or id required" }, { status: 400 });
-    }
-    const videoUrl = `https://www.youtube.com/watch?v=${vid}`;
-    const opts = normalizeChunkOpts(chunk);
-
-    // 1) метаданные (не критично)
-    stage = "meta";
-    const meta = await oembed(videoUrl);
-
-    if (dryRun) {
-      return NextResponse.json({
-        ok: true,
-        ns,
-        slot,
-        videoId: vid,
-        url: videoUrl,
-        title: meta?.title || null,
-        author: meta?.author_name || null,
-        textChunks: 0,
-        preview: null,
-        method: null,
-        ms: Date.now() - t0,
-        dryRun: true,
-      });
-    }
-
-    // 2) транскрипт: многоуровневый фоллбэк
-    stage = "transcript";
-    let items = await fetchTranscript(vid, lang);
-    let method: "captions" | "whisper" = "captions";
-
-    if (!items?.length || items.map((i) => i.text).join(" ").trim().length < minChars) {
-      stage = "whisper";
-      tmpAudio = await downloadAudioToWav(vid);
-      const text = await transcribeWithWhisper(tmpAudio, lang);
-      if (!text || text.length < minChars) {
-        try { if (tmpAudio) fs.rmSync(path.dirname(tmpAudio), { recursive: true, force: true }); } catch {}
-        return NextResponse.json(
-          { ok: false, stage, error: "transcript too short", debug: { method: "whisper", len: text?.length ?? 0 } },
-          { status: 400 }
-        );
-      }
-      items = text.split(/\n{2,}/g).map((p) => ({ text: p.trim() })).filter((x) => x.text.length > 0);
-      method = "whisper";
-    }
-
-    // 3) собрать текст
-    stage = "compose";
-    const text =
-      method === "captions"
-        ? (includeTimestamps
-            ? items.map((it) => `[${msToTimestamp((it.offset || 0) * 1000)}] ${it.text}`).join("\n")
-            : items.map((it) => it.text).join(" ").replace(/\s+\n\s+/g, "\n").trim())
-        : items.map((it) => it.text).join("\n").replace(/\s+\n\s+/g, "\n").trim();
-
-    if (!text || text.length < minChars) {
-      try { if (tmpAudio) fs.rmSync(path.dirname(tmpAudio), { recursive: true, force: true }); } catch {}
-      return NextResponse.json(
-        { ok: false, stage: "compose", error: "transcript too short", debug: { method, len: text?.length ?? 0 } },
-        { status: 400 }
-      );
-    }
-
-    // 4) chunk → upsert
-    stage = "chunk";
-    const parts = chunkText(text, opts);
-    if (!parts.length) {
-      try { if (tmpAudio) fs.rmSync(path.dirname(tmpAudio), { recursive: true, force: true }); } catch {}
-      return NextResponse.json({
-        ok: true,
-        ns, slot,
-        videoId: vid, url: videoUrl,
-        method,
-        textChunks: 0,
-        textInserted: 0,
-        textUpdated: 0,
-        unchanged: 0,
-        embedWritten: 0,
-        ms: Date.now() - t0,
-      });
-    }
-
-    const sourceId = `youtube:${vid}`;
-    const doc: IngestDoc = {
-      ns,
-      slot,
-      source_id: sourceId,
-      url: videoUrl,
-      title: meta?.title || null,
-      published_at: null,
-      source_type: "youtube",
-      kind: kind || "youtube",
-      doc_metadata: {
-        source_type: "youtube",
-        videoId: vid,
-        url: videoUrl,
-        lang: lang || null,
-        includeTimestamps: !!includeTimestamps,
-        oembed: meta || null,
-        chunk: opts,
-        chunk_total: parts.length,
-        method,
-      },
-      chunks: parts.map((content, i) => ({
-        content,
-        chunk_no: i,
-        metadata: {
-          source_type: "youtube",
-          videoId: vid,
-          url: videoUrl,
-          lang: lang || null,
-          includeTimestamps: !!includeTimestamps,
-          chunk: opts,
-          chunk_chars: content.length,
-          method,
-        },
-      })),
-    };
-
-    stage = "db-upsert";
-    const { inserted, updated, targets, unchanged } = await upsertChunksWithTargets([doc]);
-
-    // 5) эмбеддинги
-    let embedWritten = 0;
-    if (!skipEmbeddings && targets.length) {
-      stage = "embed";
-      const vectorsRaw = await embedMany(targets.map((t) => t.content));
-
-      const toPgVector = (v: any): string => {
-        const arr: number[] = Array.isArray(v)
-          ? v.map((x) => Number(x))
-          : Array.isArray((v as any)?.embedding)
-          ? (v as any).embedding.map((x: any) => Number(x))
-          : [];
-        if (!arr.length) throw new Error("Empty embedding vector");
-        return `[${arr.join(",")}]`;
-      };
-
-      const ids = targets.map((t) => t.id);
-      const vecs = vectorsRaw.map((v: any) => toPgVector(v));
-
-      stage = "db-embed";
-      const { pool } = await import("@/lib/pg");
-      const client = await pool.connect();
-      try {
-        await client.query("BEGIN");
-        await client.query(
-          `
-          WITH data AS (
-            SELECT UNNEST($1::text[]) AS id, UNNEST($2::text[]) AS vec
-          )
-          UPDATE chunks c
-          SET embedding = data.vec::vector, updated_at = NOW()
-          FROM data
-          WHERE c.id = data.id
-          `,
-          [ids, vecs]
-        );
-        await client.query("COMMIT");
-        embedWritten = ids.length;
-      } catch (e) {
-        await client.query("ROLLBACK");
-        throw e;
-      } finally {
-        client.release();
-      }
-    }
-
-    try { if (tmpAudio) fs.rmSync(path.dirname(tmpAudio), { recursive: true, force: true }); } catch {}
-
-    return NextResponse.json({
-      ok: true,
-      ns, slot,
-      videoId: vid,
-      url: videoUrl,
-      title: meta?.title || null,
-      method,
-      textChunks: parts.length,
-      textInserted: inserted,
-      textUpdated: updated,
-      unchanged,
-      embedWritten,
-      ms: Date.now() - t0,
-    });
-  } catch (e: any) {
-    try { if (tmpAudio) fs.rmSync(path.dirname(tmpAudio), { recursive: true, force: true }); } catch {}
-    return NextResponse.json({ ok: false, stage, error: e?.message || String(e) }, { status: 500 });
-  }
+export async function HEAD() {
+  return disabledResponse();
 }
-- 
2.43.0

