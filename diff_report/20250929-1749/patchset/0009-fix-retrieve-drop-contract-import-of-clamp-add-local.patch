From ae212540ca1b7df7fe4b26ef40c5988af70ca1ba Mon Sep 17 00:00:00 2001
From: zhenya3133 <verbenkoe@gmail.com>
Date: Thu, 25 Sep 2025 15:09:21 +0300
Subject: [PATCH 09/14] fix(retrieve): drop contract import of clamp; add local
 clamp + safe defaults for topK/candidateK/minSimilarity

---
 apps/web/src/lib/retriever_v2.ts | 119 ++++++++-----------------------
 1 file changed, 31 insertions(+), 88 deletions(-)

diff --git a/apps/web/src/lib/retriever_v2.ts b/apps/web/src/lib/retriever_v2.ts
index a3db3e2..fe97a98 100644
--- a/apps/web/src/lib/retriever_v2.ts
+++ b/apps/web/src/lib/retriever_v2.ts
@@ -5,7 +5,7 @@ import {
   RetrieveRequest,
   RetrieveResponse,
   RetrieveItem,
-  clamp,
+  // clamp,          // <-- больше НЕ импортируем из контракта
 } from "@/lib/retrieval-contract";
 import { matchesDomain } from "@/lib/domain_filter";
 
@@ -13,6 +13,16 @@ const ALPHA = Number(process.env.RETRIEVE_ALPHA ?? 0.85);
 const BETA = Number(process.env.RETRIEVE_BETA ?? 0.15);
 const HALF_LIFE_DAYS = Number(process.env.RETRIEVE_T_HALF ?? 180);
 
+// Локальная утилита вместо импорта из контракта
+function clamp(x: number, min: number, max: number): number {
+  return Math.max(min, Math.min(max, x));
+}
+// Безопасные числовые дефолты
+function numOr<T extends number>(v: any, d: T): T {
+  const n = Number(v);
+  return Number.isFinite(n) ? (n as T) : d;
+}
+
 function timeDecay(publishedAt: string | null): number {
   if (!publishedAt) return 0.5;
   const t = Date.parse(publishedAt);
@@ -40,16 +50,12 @@ type Row = {
 function buildDomainSQL(df: RetrieveRequest["domainFilter"]) {
   const clauses: string[] = [];
   const params: string[] = [];
-
-  // host = нижний регистр хоста из url (если url валидна)
-  // regexp_replace берёт первую группу хоста
   const hostExpr = `lower(NULLIF(regexp_replace(url, '^https?://([^/]+).*$', '\\1'), ''))`;
 
   if (df?.allow && df.allow.length) {
     const allowOrs: string[] = [];
     for (const d of df.allow) {
       const dom = d.toLowerCase().trim();
-      // host = d  OR  host LIKE '%.d'
       allowOrs.push(`(${hostExpr} = $AL${params.length + 1} OR ${hostExpr} LIKE $AL${params.length + 2})`);
       params.push(dom, `%.${dom}`);
     }
@@ -64,14 +70,14 @@ function buildDomainSQL(df: RetrieveRequest["domainFilter"]) {
     }
   }
 
-  // заменим префиксы $AL/$DN на обычные $1,$2,... когда приклеим к общему массиву
   return { clause: clauses.length ? clauses.join(" AND ") : "", rawParams: params };
 }
 
 export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse> {
-  // калибровка чисел
-  const candidateK = clamp(req.candidateK, Math.max(1, req.topK), 1000);
-  const topK = clamp(req.topK, 1, 50);
+  // безопасные дефолты
+  const topK = clamp(numOr(req.topK, 5), 1, 50);
+  const candidateK = clamp(numOr(req.candidateK, Math.max(5, topK)), topK, 1000);
+  const minSimilarity = numOr(req.minSimilarity, 0);
 
   // эмбеддинг запроса
   const qvec = await embedQuery(req.q);
@@ -79,87 +85,23 @@ export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse
   // ns-фильтр
   const nsExact = req.ns;
   const nsLike = `${req.ns}/%`;
-  const whereNs =
-    req.nsMode === "strict"
-      ? `ns = $2`
-      : `(ns = $2 OR ns LIKE $3)`;
-
-  // доменные предикаты — если есть allow/deny, ограничим кандидатов уже в SQL
-  const { clause: domainClauseRaw, rawParams: domainParamsRaw } = buildDomainSQL(req.domainFilter);
-
-  // строим основной текст запроса с «дыркой» под домен
-  const base = `
-    SELECT
-      id, ns, slot, url, title, content,
-      COALESCE(to_char(published_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'), NULL) AS published_at,
-      source_type, kind, metadata,
-      (1 - (embedding <=> $VEC::vector)) AS sim
-    FROM chunks
-    WHERE slot = $1
-      AND ${whereNs}
-      ${domainClauseRaw ? `AND (${domainClauseRaw})` : ``}
-    ORDER BY embedding <=> $VEC::vector ASC
-    LIMIT $LIM
-  `;
+  const whereNs = req.nsMode === "strict" ? `ns = $2` : `(ns = $2 OR ns LIKE $3)`;
 
-  // собираем параметры в правильном порядке и пронумеровываем плейсхолдеры
-  // шаблонные маркеры: $VEC, $LIM, $ALn/$DNn — заменим на обычные $1..$N
-  const params: any[] = [];
+  // доменные предикаты
+  const { clause: domainClauseRaw } = buildDomainSQL(req.domainFilter);
 
-  // $1, $2, ($3 если prefix)
-  params.push(req.slot, nsExact);
-  let text = base;
-
-  if (req.nsMode !== "strict") {
-    params.push(nsLike);
-  } else {
-    // убираем $3 из текста
-    text = text.replace("ns LIKE $3", "/* nsLike omitted in strict */ TRUE");
-  }
-
-  // доменные параметры
-  for (const p of domainParamsRaw) params.push(p);
-
-  // подставим $VEC и $LIM в конец массива
-  params.push(`[${qvec.join(",")}]`);
-  params.push(candidateK);
-
-  // теперь нужно перенумеровать плейсхолдеры по порядку:
-  // $1..$N уже заняты, а $VEC и $LIM — символические; также $ALn/$DNn нужно заменить.
-  // Сформируем мапу замен:
-  let idx = 1;
-  const replace = (s: string) => {
-    // порядок: slot($1), nsExact($2), nsLike($3?) уже на месте, так что найдём спец-теги
-    // пронумеруем AL/DN по порядку появления
-    let t = s;
-    // AL/DN
-    const aldn = t.match(/\$A[L]\d+|\$D[N]\d+/g) || [];
-    for (const tag of aldn) {
-      // вычислим номер параметра этого тэга в массиве:
-      // это всё, что идёт после базовых (slot/ns[/nsLike])
-      // проще: пройдём по строке и заменим по очереди на $k, инкрементируя счётчик,
-      // но нам нужно не задеть уже существующие $1/$2/$3.
-    }
-    return t;
-  };
-
-  // Проще: соберём текст заново с нумерацией через шаблон
-  // Строим список условий заново, зная точные индексы
-  const startCount = params.length - 2 - domainParamsRaw.length - (req.nsMode !== "strict" ? 3 : 2);
-  // но это излишне сложно. Пойдём проще: не использовать символические плейсхолдеры.
-
-  // --- ПРОЩЕ И НАДЁЖНЕЕ: сформируем текст динамически со стандартной нумерацией ---
-
-  const whereParts: string[] = [`slot = $1`, req.nsMode === "strict" ? `ns = $2` : `(ns = $2 OR ns LIKE $3)`];
+  // Соберём WHERE с нормальной нумерацией плейсхолдеров
+  const whereParts: string[] = [
+    `slot = $1`,
+    whereNs,
+  ];
   let next = req.nsMode === "strict" ? 3 : 4;
 
   if (domainClauseRaw) {
-    // пересоберём доменный блок с обычной нумерацией
-    // domainParamsRaw идёт парами (value, %.value)
+    // Пересобираем allow/deny с обычной нумерацией
     const hostExpr = `lower(NULLIF(regexp_replace(url, '^https?://([^/]+).*$', '\\1'), ''))`;
     const allow = req.domainFilter?.allow ?? [];
     const deny = req.domainFilter?.deny ?? [];
-
     const parts: string[] = [];
 
     if (allow.length) {
@@ -168,10 +110,10 @@ export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse
         const a1 = `$${next++}`;
         const a2 = `$${next++}`;
         ors.push(`(${hostExpr} = ${a1} OR ${hostExpr} LIKE ${a2})`);
-        params.splice(params.length - 2, 0); // no-op; мы позже добавим сами
       }
       parts.push(`url IS NOT NULL AND (${ors.join(" OR ")})`);
     }
+
     if (deny.length) {
       for (let i = 0; i < deny.length; i++) {
         const d1 = `$${next++}`;
@@ -179,10 +121,10 @@ export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse
         parts.push(`NOT ( ${hostExpr} = ${d1} OR ${hostExpr} LIKE ${d2} )`);
       }
     }
-    whereParts.push(parts.join(" AND "));
+
+    if (parts.length) whereParts.push(parts.join(" AND "));
   }
 
-  // теперь окончательный текст
   const finalSQL = `
     SELECT
       id, ns, slot, url, title, content,
@@ -195,7 +137,7 @@ export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse
     LIMIT $${next + 1}
   `;
 
-  // ПЕРЕСОБИРАЕМ params последовательно:
+  // Параметры в правильном порядке:
   const finalParams: any[] = [];
   finalParams.push(req.slot, nsExact);
   if (req.nsMode !== "strict") finalParams.push(nsLike);
@@ -219,8 +161,8 @@ export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse
   const res = await pool.query<Row>(finalSQL, finalParams);
   const rows: Row[] = res.rows;
 
-  // пост-фильтры (на случай deny/allow без SQL — но мы уже сузили allow в SQL)
-  const afterSim: Row[] = rows.filter((r: Row) => r.sim >= req.minSimilarity);
+  // пост-фильтр по схожести + домены
+  const afterSim: Row[] = rows.filter((r: Row) => r.sim >= minSimilarity);
   const afterDomain: Row[] = afterSim.filter((r: Row) => matchesDomain(r.url, req.domainFilter));
 
   // скоринг + topK
@@ -244,5 +186,6 @@ export async function retrieveV2(req: RetrieveRequest): Promise<RetrieveResponse
     denySkipped: rows.length - afterDomain.length,
   };
 
+  // Контракт текущей версии: без поля ok
   return { items, filterInfo, debugVersion: "rc-v1" };
 }
-- 
2.43.0

