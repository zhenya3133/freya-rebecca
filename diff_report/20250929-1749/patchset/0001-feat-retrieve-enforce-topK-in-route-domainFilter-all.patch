From 72a39c29077411e857e401bcc707fe6e916ee89e Mon Sep 17 00:00:00 2001
From: zhenya3133 <verbenkoe@gmail.com>
Date: Sun, 21 Sep 2025 21:56:34 +0300
Subject: [PATCH 01/14] feat(retrieve): enforce topK in route; domainFilter
 allow/deny (+subdomains); recency mix + debugVersion
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- /api/retrieve уважает topK из тела запроса
- retrieveV2: domainFilter {allow, deny} с учётом поддоменов
- score = (1-α)*similarity + α*recency (α настраивается)
- filterInfo (before/after/dropped) в ответе
- debugVersion=r2-domains-slice-v2
- lib/pg: Pool + простой tagged-template sql
---
 apps/web/src/app/api/retrieve/route.ts |  57 +++-
 apps/web/src/lib/pg.ts                 |  31 +++
 apps/web/src/lib/retriever_v2.ts       | 368 +++++++++++++++----------
 3 files changed, 306 insertions(+), 150 deletions(-)
 create mode 100644 apps/web/src/lib/pg.ts

diff --git a/apps/web/src/app/api/retrieve/route.ts b/apps/web/src/app/api/retrieve/route.ts
index e24b558..686ca44 100644
--- a/apps/web/src/app/api/retrieve/route.ts
+++ b/apps/web/src/app/api/retrieve/route.ts
@@ -20,6 +20,12 @@ type Body = {
   minSimilarity?: number;
 
   recency?: RecencyOptions | null;
+
+  // ➜ добавили доменный фильтр в контракт
+  domainFilter?: {
+    allow?: string[];
+    deny?: string[];
+  } | null;
 };
 
 export async function POST(req: Request) {
@@ -36,21 +42,62 @@ export async function POST(req: Request) {
       return NextResponse.json({ ok: false, error: "query required" }, { status: 400 });
     }
 
+    // Жёсткое приведение типов чисел (часто прилетает как string/null/undefined)
+    const topK =
+      typeof body.topK === "number" && Number.isFinite(body.topK)
+        ? Math.max(1, Math.floor(body.topK))
+        : 5;
+
+    const candidateK =
+      typeof body.candidateK === "number" && Number.isFinite(body.candidateK)
+        ? Math.max(topK, Math.floor(body.candidateK))
+        : 200;
+
+    const minSimilarity =
+      typeof body.minSimilarity === "number" && Number.isFinite(body.minSimilarity)
+        ? body.minSimilarity
+        : undefined;
+
+    // Корректно пробрасываем domainFilter (если массивы пустые — тоже пробрасываем)
+    const domainFilter =
+      body.domainFilter && typeof body.domainFilter === "object"
+        ? {
+            allow: Array.isArray(body.domainFilter.allow) ? body.domainFilter.allow : undefined,
+            deny: Array.isArray(body.domainFilter.deny) ? body.domainFilter.deny : undefined,
+          }
+        : null;
+
+    // Recency по умолчанию
+    const recency: RecencyOptions =
+      body.recency && typeof body.recency === "object"
+        ? {
+            enabled: body.recency.enabled ?? true,
+            halfLifeDays: body.recency.halfLifeDays ?? 30,
+            weight: body.recency.weight ?? 0.2,
+            usePublishedAt: body.recency.usePublishedAt ?? false,
+          }
+        : { enabled: true, halfLifeDays: 30, weight: 0.2, usePublishedAt: false };
+
     stage = "retrieve";
     const result = await retrieveV2({
       ns: body.ns,
       slot: body.slot ?? "staging",
       query: body.query,
-      topK: body.topK ?? 5,
-      candidateK: body.candidateK ?? 200,
+      topK,                    // ✅ теперь точно topK
+      candidateK,              // ✅ и candidateK
       nsMode: body.nsMode ?? "strict",
       includeKinds: body.includeKinds ?? null,
       includeSourceTypes: body.includeSourceTypes ?? null,
-      minSimilarity: typeof body.minSimilarity === "number" ? body.minSimilarity : undefined,
-      recency: body.recency ?? { enabled: true, halfLifeDays: 30, weight: 0.2, usePublishedAt: false },
+      minSimilarity,           // может быть undefined
+      recency,
+      domainFilter,            // ✅ пробрасываем фильтр доменов
     });
 
-    return NextResponse.json({ ok: true, ...result, took_ms_route: Date.now() - t0 });
+    // Небольшой маячок, помогает в отладке энд-ту-энд
+    return NextResponse.json(
+      { ok: true, ...result, took_ms_route: Date.now() - t0, routeVersion: "retrieve-route-v2.1" },
+      { status: 200 },
+    );
   } catch (e: any) {
     return NextResponse.json(
       { ok: false, stage, error: e?.message || String(e) },
diff --git a/apps/web/src/lib/pg.ts b/apps/web/src/lib/pg.ts
new file mode 100644
index 0000000..1dc9376
--- /dev/null
+++ b/apps/web/src/lib/pg.ts
@@ -0,0 +1,31 @@
+// apps/web/src/lib/pg.ts
+import { Pool } from "pg";
+
+const connStr = process.env.DATABASE_URL;
+if (!connStr) {
+  throw new Error("DATABASE_URL is not set");
+}
+
+export const pool = new Pool({ connectionString: connStr });
+
+/**
+ * Примитивный tagged-template, похожий на postgres.js `sql``:
+ *   const rows = await sql`select * from memories where id = ${id}`;
+ * Он подставит $1,$2,… и вернёт rows.
+ */
+export async function sql(
+  strings: TemplateStringsArray,
+  ...values: any[]
+): Promise<any[]> {
+  // Собираем текст с плейсхолдерами $1..$n
+  let text = "";
+  for (let i = 0; i < strings.length; i++) {
+    text += strings[i];
+    if (i < values.length) text += `$${i + 1}`;
+  }
+  const res = await pool.query(text, values);
+  return res.rows;
+}
+
+// На всякий случай пригодится тип
+export type SQL = typeof sql;
diff --git a/apps/web/src/lib/retriever_v2.ts b/apps/web/src/lib/retriever_v2.ts
index 4c35b29..94529e1 100644
--- a/apps/web/src/lib/retriever_v2.ts
+++ b/apps/web/src/lib/retriever_v2.ts
@@ -1,190 +1,268 @@
 // apps/web/src/lib/retriever_v2.ts
-import { pool } from "@/lib/db";
-import { embedMany } from "@/lib/embeddings";
-
-/** Безопасный embedQuery: несколько попыток импорта, иначе fallback на embedMany */
-async function embedQuerySafe(q: string): Promise<number[]> {
-  try {
-    const modRel = await import("./embeddings");
-    if (typeof (modRel as any).embedQuery === "function") {
-      return await (modRel as any).embedQuery(q);
-    }
-  } catch {}
-  try {
-    const modAlias = await import("@/lib/embeddings");
-    if (typeof (modAlias as any).embedQuery === "function") {
-      return await (modAlias as any).embedQuery(q);
-    }
-  } catch {}
-  const [v] = await embedMany([q]);
-  return v;
-}
+import { embedQuery } from "@/lib/embeddings";
+import { pool } from "@/lib/pg";
 
+/** Настройки «свежести» результата. */
 export type RecencyOptions = {
-  enabled?: boolean;
-  halfLifeDays?: number;
-  weight?: number;
-  usePublishedAt?: boolean;
+  enabled: boolean;
+  halfLifeDays: number;    // период полураспада (дни)
+  weight: number;          // вес свежести в итоговом score [0..1]
+  usePublishedAt: boolean; // брать published_at из metadata, иначе created_at
 };
 
-export type RetrieveParams = {
+/** Фильтр доменов по URL в metadata->>'url'. */
+export type DomainFilter = {
+  allow?: string[];
+  deny?: string[];
+};
+
+type RetrieveParams = {
   ns: string;
-  slot?: string | null;
+  slot: string;
   query: string;
-  topK?: number;
-  candidateK?: number;
+
+  topK: number;
+  candidateK: number;
+
   nsMode?: "strict" | "prefix";
   includeKinds?: string[] | null;
   includeSourceTypes?: string[] | null;
-  minSimilarity?: number;
-  recency?: RecencyOptions;
+
+  minSimilarity?: number;            // [0..1]
+  recency?: RecencyOptions | null;
+  domainFilter?: DomainFilter | null;
 };
 
-export type RetrievedMatch = {
+type Row = {
   id: string;
-  kind: string | null;
+  kind: string;
   ns: string;
-  slot: string | null;
+  slot: string;
   content: string;
   metadata: any;
-  created_at: string;
-  sim: number;
-  rec: number;
-  score: number;
-  sample: string;
+  created_at: string | null;
+  dist: number;     // расстояние
+  sim_raw: number;  // 1/(1+dist)
 };
 
-export type RetrieveResult = {
-  ok: true;
-  took_ms: number;
-  params: Omit<RetrieveParams, "query"> & { query: string };
-  recencyEffective: { enabled: boolean; halfLifeDays: number; weight: number; usedPublishedAt: boolean };
-  candidates: number;
-  returned: number;
-  matches: RetrievedMatch[];
-};
+function clamp01(x: number) {
+  return Math.max(0, Math.min(1, x));
+}
 
-function clamp(n: number, lo: number, hi: number) {
-  return Math.max(lo, Math.min(hi, n));
+function nowUtc(): number {
+  return Date.now();
 }
 
-function buildFilterSql(nsMode: "strict" | "prefix", hasKinds: boolean, hasSrcTypes: boolean) {
-  const nsClause =
-    nsMode === "prefix"
-      ? "ns LIKE ($2 || '%') AND ($3::text IS NULL OR slot = $3)"
-      : "ns = $2 AND ($3::text IS NULL OR slot = $3)";
-  const parts: string[] = [`(${nsClause})`];
-  if (hasKinds) parts.push("(kind = ANY($5::text[]))");
-  if (hasSrcTypes) parts.push("(metadata->>'source_type' = ANY($6::text[]))");
-  return parts.join(" AND ");
+function daysBetween(fromIso: string | null | undefined): number {
+  if (!fromIso) return 99999;
+  const t = Date.parse(fromIso);
+  if (!Number.isFinite(t)) return 99999;
+  return (nowUtc() - t) / (1000 * 60 * 60 * 24);
 }
 
-export async function retrieveV2(params: RetrieveParams): Promise<RetrieveResult> {
-  const t0 = Date.now();
-  const {
-    ns, slot = "staging", query,
-    topK = 5, candidateK = 200,
-    nsMode = "strict",
-    includeKinds, includeSourceTypes,
-    minSimilarity,
-    recency,
-  } = params;
-
-  if (!ns) throw new Error("ns is required");
-  if (!query?.trim()) throw new Error("query is empty");
-
-  // 1) эмбеддинг запроса
-  const qvec = await embedQuerySafe(query);
-  // ВАЖНО: pgvector ждёт строковый литерал в формате [a,b,c]
-  const qvecLit = "[" + qvec.join(",") + "]";
-
-  // 2) кандидаты из ANN
-  const K = clamp(topK, 1, 50);
-  const CAND = clamp(candidateK, K, 1000);
-  const hasKinds = Array.isArray(includeKinds) && includeKinds.length > 0;
-  const hasSrcTypes = Array.isArray(includeSourceTypes) && includeSourceTypes.length > 0;
-
-  const where = buildFilterSql(nsMode, hasKinds, hasSrcTypes);
-  const sql = `
-    SELECT id, kind, ns, slot, content, metadata, created_at,
-           (embedding <=> $1::vector) AS dist
-    FROM memories
-    WHERE ${where}
-    ORDER BY embedding <=> $1::vector
-    LIMIT $4
+/** Простая нормализация L2-distance к похожести [0..1]. */
+function simFromL2(dist: number): number {
+  return 1 / (1 + Math.max(0, dist));
+}
+
+/** Экспоненциальный «полураспад» свежести. */
+function recencyBoost(days: number, halfLifeDays: number): number {
+  if (halfLifeDays <= 0) return 1;
+  return Math.exp(-Math.log(2) * (days / halfLifeDays));
+}
+
+/** Безопасно парсим hostname. */
+function hostFromUrl(u?: string | null): string | null {
+  if (!u) return null;
+  try {
+    const raw = new URL(u).hostname.toLowerCase();
+    const h = raw.startsWith("www.") ? raw.slice(4) : raw;
+    return h || null;
+  } catch {
+    return null;
+  }
+}
+
+/** Сопоставление домена с учётом поддоменов. */
+function hostMatchesRule(host: string, rule: string): boolean {
+  const r = rule.toLowerCase().replace(/^www\./, "");
+  if (host === r) return true;
+  return host.endsWith("." + r);
+}
+
+/** Собираем литерал вектора для pgvector: '[1,2,3]' */
+function vectorLiteral(vec: number[]): string {
+  const nums = vec.map((v) => (Number.isFinite(v) ? Number(v) : 0)).join(",");
+  return `[${nums}]`;
+}
+
+export async function retrieveV2(p: RetrieveParams) {
+  const started = Date.now();
+
+  const nsMode = p.nsMode ?? "strict";
+  const includeKinds = p.includeKinds ?? null;
+  const includeSourceTypes = p.includeSourceTypes ?? null;
+
+  const recency: RecencyOptions = {
+    enabled: p.recency?.enabled ?? true,
+    halfLifeDays: p.recency?.halfLifeDays ?? 30,
+    weight: p.recency?.weight ?? 0.2,
+    usePublishedAt: p.recency?.usePublishedAt ?? false,
+  };
+
+  const topK = Math.max(1, Math.min(p.topK ?? 5, 1000));
+  const candidateK = Math.max(topK, Math.min(p.candidateK ?? 200, 10000));
+  const minSim = typeof p.minSimilarity === "number" ? clamp01(p.minSimilarity) : undefined;
+
+  // 1) Эмбеддинг запроса
+  const qEmb = await embedQuery(p.query);
+  if (!Array.isArray(qEmb) || qEmb.length < 8) {
+    throw new Error("embedQuery returned invalid vector");
+  }
+  const qvLiteral = vectorLiteral(qEmb); // "[…]"
+
+  // 2) WHERE-условия
+  const clauses: string[] = [];
+  const params: any[] = [];
+
+  if (nsMode === "prefix") {
+    params.push(p.ns, `${p.ns}/%`);
+    clauses.push(`(m.ns = $${params.length - 1} OR m.ns LIKE $${params.length})`);
+  } else {
+    params.push(p.ns);
+    clauses.push(`m.ns = $${params.length}`);
+  }
+
+  params.push(p.slot);
+  clauses.push(`m.slot = $${params.length}`);
+
+  clauses.push(`m.embedding IS NOT NULL`);
+
+  if (includeKinds && includeKinds.length) {
+    params.push(includeKinds);
+    clauses.push(`m.kind = ANY($${params.length})`);
+  }
+  if (includeSourceTypes && includeSourceTypes.length) {
+    params.push(includeSourceTypes);
+    clauses.push(`(m.metadata->>'source_type') = ANY($${params.length})`);
+  }
+
+  // 3) SQL кандидатов (вектор как $X::vector)
+  params.push(qvLiteral);
+  const idxVec = params.length;
+
+  params.push(candidateK);
+  const idxLimit = params.length;
+
+  const text = `
+    WITH params AS (
+      SELECT $${idxVec}::vector AS qv
+    )
+    SELECT
+      m.id, m.kind, m.ns, m.slot, m.content, m.metadata, m.created_at,
+      (m.embedding <-> (SELECT qv FROM params)) AS dist,
+      (1.0 / (1.0 + (m.embedding <-> (SELECT qv FROM params)))) AS sim_raw
+    FROM memories m
+    WHERE ${clauses.join(" AND ")}
+    ORDER BY m.embedding <-> (SELECT qv FROM params)
+    LIMIT $${idxLimit}
   `;
-  const args: any[] = [qvecLit, ns, slot, CAND];
-  if (hasKinds) args.push(includeKinds);
-  if (hasSrcTypes) { if (!hasKinds) args.push([]); args.push(includeSourceTypes); }
-
-  const { rows } = await pool.query(sql, args);
-
-  // 3) доранжировка: similarity + recency
-  const alpha = 1 - (recency?.weight ?? 0.2);
-  const beta  = (recency?.weight ?? 0.2);
-  const half  = clamp(Math.floor(recency?.halfLifeDays ?? Number(process.env.RECENCY_HALFLIFE_DAYS || 30)), 1, 3650);
-  const usePub = !!recency?.usePublishedAt;
-  const recOn = recency?.enabled !== false;
-
-  const LN2 = Math.log(2);
-  const now = Date.now();
-
-  function recencyBoost(r: any) {
-    let t = r.created_at ? new Date(r.created_at).getTime() : 0;
-    if (usePub) {
-      const p = r?.metadata?.published_at ?? r?.metadata?.["published_at"];
-      if (typeof p === "string") {
-        const tp = Date.parse(p);
-        if (!Number.isNaN(tp)) t = tp;
-      }
-    }
-    if (!t) return 0;
-    const ageDays = (now - t) / (1000 * 60 * 60 * 24);
-    return Math.exp(-LN2 * (ageDays / half));
+
+  let rows: Row[] = [];
+  try {
+    const r = await pool.query(text, params);
+    rows = r.rows as Row[];
+  } catch (e: any) {
+    throw new Error(`SQL retrieve failed: ${e?.message || String(e)}`);
   }
 
-  const rescored = rows
+  const candidates = rows.length;
+
+  // 4) Доменный фильтр + скоринг со свежестью
+  const allow = (p.domainFilter?.allow ?? []).map((s) => s.toLowerCase().replace(/^www\./, ""));
+  const deny  = (p.domainFilter?.deny  ?? []).map((s) => s.toLowerCase().replace(/^www\./, ""));
+  const useDomainFilter = allow.length > 0 || deny.length > 0;
+
+  const filtered = rows.filter((r) => {
+    if (!useDomainFilter) return true;
+    const h = hostFromUrl(r?.metadata?.url);
+    if (!h) return false;
+
+    if (deny.length && deny.some((d) => hostMatchesRule(h, d))) return false;
+    if (allow.length && !allow.some((a) => hostMatchesRule(h, a))) return false;
+
+    return true;
+  });
+
+  const afterDomain = filtered.length;
+
+  const scored = filtered
     .map((r) => {
-      const sim = 1 - Number(r.dist);
-      const rec = recOn ? recencyBoost(r) : 0;
-      const score = alpha * sim + beta * rec;
-      return { ...r, sim, rec, score };
+      const sim = clamp01(simFromL2(r.dist));
+      const ageIso =
+        (recency.usePublishedAt ? r?.metadata?.published_at : null) ||
+        r.created_at ||
+        null;
+      const ageDays = daysBetween(ageIso);
+      const recent = recency.enabled ? recencyBoost(ageDays, recency.halfLifeDays) : 1;
+
+      const alpha = clamp01(recency.weight);
+      const score = (1 - alpha) * sim + alpha * recent;
+
+      return { r, sim, recent, score };
     })
-    .filter((r) => (typeof minSimilarity === "number" ? r.sim >= minSimilarity : true))
-    .sort((a, b) => b.score - a.score)
-    .slice(0, K);
+    .filter((x) => (minSim !== undefined ? x.sim >= minSim : true))
+    .sort((a, b) => b.score - a.score);
 
-  const matches: RetrievedMatch[] = rescored.map((r) => ({
+  // ВАЖНО: ограничиваем именно здесь, после сортировки
+  const matchesRaw = scored.slice(0, topK);
+
+  const matches = matchesRaw.map(({ r, sim, recent, score }) => ({
     id: r.id,
-    kind: r.kind ?? null,
+    kind: r.kind,
     ns: r.ns,
-    slot: r.slot ?? null,
+    slot: r.slot,
     content: r.content,
     metadata: r.metadata,
     created_at: r.created_at,
-    sim: Number((r as any).sim.toFixed(4)),
-    rec: Number((r as any).rec.toFixed(4)),
-    score: Number((r as any).score.toFixed(4)),
-    sample: (r.content as string)?.slice(0, 240) || "",
+    sim,
+    rec: recent,
+    score,
+    sample: r.content?.slice(0, 240) ?? "",
   }));
 
+  const filterInfo =
+    useDomainFilter
+      ? {
+          allow: allow.length ? allow : undefined,
+          deny: deny.length ? deny : undefined,
+          candidatesBefore: candidates,
+          candidatesAfter: afterDomain,
+          dropped: Math.max(0, candidates - afterDomain),
+        }
+      : null;
+
   return {
     ok: true,
-    took_ms: Date.now() - t0,
+    took_ms: Date.now() - started,
     params: {
-      ns, slot, query,
-      topK: K, candidateK: CAND,
+      ns: p.ns,
+      slot: p.slot,
+      query: p.query,
+      topK,
+      candidateK,
       nsMode,
-      includeKinds: includeKinds ?? null,
-      includeSourceTypes: includeSourceTypes ?? null,
-      minSimilarity: typeof minSimilarity === "number" ? minSimilarity : undefined,
+      includeKinds,
+      includeSourceTypes,
+      minSimilarity: minSim,
       recency,
+      domainFilter: p.domainFilter ?? null,
     },
-    recencyEffective: {
-      enabled: recOn, halfLifeDays: half, weight: beta, usedPublishedAt: usePub,
-    },
-    candidates: rows.length,
-    returned: matches.length,
+    recencyEffective: { ...recency },
+    candidates,                // сколько кандидатов до пост-фильтров
+    returned: matches.length,  // сколько реально вернули (≤ topK)
+    filterInfo,                // null если фильтр не применялся
     matches,
+    debugVersion: "r2-domains-slice-v2",
   };
 }
-- 
2.43.0

